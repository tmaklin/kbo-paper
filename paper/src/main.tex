%%
%% Copyright 2022 OXFORD UNIVERSITY PRESS
%%
%% This file is part of the 'oup-authoring-template Bundle'.
%% ---------------------------------------------
%%
%% It may be distributed under the conditions of the LaTeX Project Public
%% License, either version 1.2 of this license or (at your option) any
%% later version.  The latest version of this license is in
%%    http://www.latex-project.org/lppl.txt
%% and version 1.2 or later is part of all distributions of LaTeX
%% version 1999/12/01 or later.
%%
%% The list of all files belonging to the 'oup-authoring-template Bundle' is
%% given in the file `manifest.txt'.
%%
%% Template article for OXFORD UNIVERSITY PRESS's document class `oup-authoring-template' 
%% with bibliographic references
%%

%%%CONTEMPORARY%%%
\documentclass[unnumsec,webpdf,contemporary,large]{oup-authoring-template}%
%\documentclass[unnumsec,webpdf,contemporary,large,namedate]{oup-authoring-template}% uncomment this line for author year citations and comment the above
%\documentclass[unnumsec,webpdf,contemporary,medium]{oup-authoring-template}
%\documentclass[unnumsec,webpdf,contemporary,small]{oup-authoring-template}

%%%MODERN%%%
%\documentclass[unnumsec,webpdf,modern,large]{oup-authoring-template}
%\documentclass[unnumsec,webpdf,modern,large,namedate]{oup-authoring-template}% uncomment this line for author year citations and comment the above
%\documentclass[unnumsec,webpdf,modern,medium]{oup-authoring-template}
%\documentclass[unnumsec,webpdf,modern,small]{oup-authoring-template}

%%%TRADITIONAL%%%
%\documentclass[unnumsec,webpdf,traditional,large]{oup-authoring-template}
%\documentclass[unnumsec,webpdf,traditional,large,namedate]{oup-authoring-template}% uncomment this line for author year citations and comment the above
%\documentclass[unnumsec,namedate,webpdf,traditional,medium]{oup-authoring-template}
%\documentclass[namedate,webpdf,traditional,small]{oup-authoring-template}

%\onecolumn % for one column layouts

%\usepackage{showframe}

\graphicspath{{fig/}}

% svg images
\usepackage[inkscapelatex=false]{svg}
\usepackage[normalem]{ulem}
\usepackage{adjustbox}
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{subfigure}
%\usepackage{subcaption}
%\usepackage[noend]{algpseudocode}
\usepackage{comment}

% line numbers
%\usepackage[mathlines, switch]{lineno}
%\usepackage[right]{lineno}

\theoremstyle{thmstyleone}%
\newtheorem{theorem}{Theorem}%  meant for continuous numbers
%%\newtheorem{theorem}{Theorem}[section]% meant for sectionwise numbers
%% optional argument [theorem] produces theorem numbering sequence instead of independent numbers for Proposition
\newtheorem{proposition}[theorem]{Proposition}%
%%\newtheorem{proposition}{Proposition}% to get separate numbers for theorem and proposition etc.
\theoremstyle{thmstyletwo}%
\newtheorem{example}{Example}%
\newtheorem{remark}{Remark}%
\theoremstyle{thmstylethree}%
\newtheorem{definition}{Definition}


\begin{document}

\journaltitle{Journal Title Here}
\DOI{DOI HERE}
\copyrightyear{2022}
\pubyear{2019}
\access{Advance Access Publication Date: Day Month Year}
\appnotes{Paper}

\firstpage{1}

%\subtitle{Subject Section}

\title[Local alignment with kbo]{Local alignment search with \emph{k}-bounded matching statistics}

\author[1,$\ast$]{Tommi M\"{a}klin\ORCID{0000-0003-0970-3514}}
\author[2]{Jarno N. Alanko\ORCID{0000-0002-8003-9225}}
\author[2]{Elena Biagi\ORCID{0000-0002-8573-3603}}
\author[2]{Simon J. Puglisi\ORCID{0000-0001-7668-7636}}

\authormark{M\"{a}klin, Alanko, Biagi and Puglisi}

\address[1]{\orgdiv{Department of Biostatistics}, \orgname{University of Oslo}, \orgaddress{\street{Sognsvannsveien 9}, \postcode{0372}, \state{Oslo}, \country{Norway}}}
\address[2]{\orgdiv{Department of Computer Science}, \orgname{University of Helsinki}, \orgaddress{\street{Pietari Kalmin katu 5}, \postcode{00560}, \state{Helsinki}, \country{Finland}}}

\corresp[$\ast$]{Corresponding author. \href{email:tommi.maklin@helsinki.fi}{tommi.maklin@medisin.uio.no}}

\received{Date}{0}{Year}
\revised{Date}{0}{Year}
\accepted{Date}{0}{Year}

%\editor{Associate Editor: Name}

%\abstract{
%\textbf{Motivation:} .\\
%\textbf{Results:} .\\
%\textbf{Availability:} .\\
%\textbf{Contact:} \href{name@email.com}{name@email.com}\\
%\textbf{Supplementary information:} Supplementary data are available at \textit{Journal Name}
%online.}

\abstract{Finding high-quality local alignments between a query sequence and sequences contained in a large genomic database is a fundamental problem in computational genomics, at the core of thousands of biological analysis pipelines. Here, we describe a novel algorithm for approximate local alignment search based on the so-called \emph{k}-bounded matching statistics of the query sequence \emph{k}-mers with respect to an indexed database of sequences. We compute the \emph{k}-bounded matching statistics, which capture the longest common suffix lengths of consecutive \emph{k}-mer matches between query and target sequences, using the Spectral Burrows-Wheeler transform (SBWT), a data structure that enables computationally efficient indexed queries. We show that our method is as fast and as accurate as state-of-the-art tools in several bacterial genomics tasks. Our method is available as a set of three {\sf kbo} Rust packages that provide a command-line interface, a graphical user interface that runs in a browser without server-side processing, and a core library that can be accessed by other tools.}
\keywords{sequence alignment, genomics, spectral Burrows-Wheeler transform, \emph{k}-bounded matching statistics, \emph{k}-mer matching}

% \boxedtext{
% \begin{itemize}
% \item Key boxed text here.
% \item Key boxed text here.
% \item Key boxed text here.
% \end{itemize}}

\maketitle


\section{Introduction}
Genome analysis pipelines typically begin with aligning DNA contained in sequencing reads or assemblies against a known reference sequence. The resulting alignment describes compatibility between the two sequences and is the basis for many downstream analyses. In tasks where accuracy is essential and resources plentiful, the gold standard for alignment is to map short-read sequencing data against a short+long read hybrid-assembled reference genome \cite{wick2023assembling}. However, particularly in microbial genomics, the largest current collections contain data from hundreds of thousands to millions of samples \cite{parks2020complete,richardson2023mgnify,hunt2024allthebacteria}, rendering large-scale storage, distribution, and processing of sequencing read sets domain of only the largest institutions. This has led to adopting algorithms that perform essential tasks using only assembly data in favour of sequencing reads, as specialized tools compress assembled genomes efficiently \cite{deorowicz2023agc,bvrinda2024efficient} and tools operating on assemblies require less computational resources to analyse.

Computational tools for assembly comparison typically report the coordinates of aligned segments in a query relative to some reference, infer a consensus sequence consisting of nucleotide characters and gaps, and find structural variation in the query such as insertions and deletions. Accuracy in these three tasks highly depends on quality of the input sequences \cite{wick2025reads}, but for high-quality data the results from different tools tend to agree and their development has focused on faster or more specialized pipelines and new algorithms. In this paper we devise and implement one such algorithm for solving the aforementioned comparison tasks by pairing \emph{k}-mer matching with computation of the longest common suffix length of each match, a \emph{k}-bounded matching statistic.

Our approach, called {\sf kbo}, is built on top of the Spectral Burrows-Wheeler transform (SBWT) data structure that allows rapid \emph{k}-mer lookups in compact space \cite{alanko2023small}. Recently, these lookups were extended to computing \emph{k}-bounded matching statistics by adding a longest common suffix array to the SBWT \cite{alanko2023longest,alanko2024finimizers}. We show that combining SBWT lookups with the \emph{k}-bounded matching statistics information enables transforming otherwise locality-discarding SBWT \emph{k}-mer matching into local alignments through a suffix match derandomisation procedure. As a whole, our algorithm represents a significant advance in \emph{k}-mer matching methods, which have previously discarded coordinate information and locality in favour of scalable lookups \cite{alanko2023themisto,fan2024fulgor}.

Beyond algorithmic novelty, the main advantage of {\sf kbo} lies in its effective use of the SBWT data structure to perform comparisons in a rapid and parallelisable manner. We demonstrate that our implementation either matches or beats state-of-the-art methods in both accuracy and speed while retaining reasonable space requirements. Additionally, {\sf kbo} requires no temporary disk space, making it ideal for massively parallel analyses. The low computational requirements enable a fully in-browser implementation of our algorithms, greatly improving accessibility for non-experts and researchers with limited technical proficiency or resources. To our knowledge, {\sf kbo} is the first fully-featured sequence aligner that can run entirely in the browser while also providing an efficient command-line client and a stable core library for use in other programs. We expect our tools to facilitate further democratization of bioinformatics and find adoption in fields processing large assembly collections.

\section{Methods}\label{methods}
\subsection{Overview}

Our tool, {\sf kbo}, implements three main algorithms that all take advantage of \emph{k}-mer matching plus \emph{k}-bounded matching statistics. The first algorithm, \textit{call}, is a specialized variant calling algorithm that reports insertions, deletions, and single-nucleotide polymorphisms in a query. Call is useful for producing variant calling files that form the basis of genome-wide association studies. Our second algorithm, \textit{find}, compares a query and a reference sequence and reports local alignment segments in the query. Find is particularly useful for finding shorter sequences such as genes in a large number of queries. The last algorithm, \textit{map}, performs reference-based alignment and produces a consensus sequence relative to the reference. The main use for map is in producing such alignments for many queries in a fast and highly parallelisable manner. The following paragraphs will give a detailed overview of the theory required to implement each algorithm.

\begin{figure*}[b]
    \centering
    \includegraphics[scale=0.6]{fig/SBWT_search_LCS.drawio.pdf}
    \caption{Illustration of {\em ExtendRight} (resulting in blue intervals) and {\em ContractLeft} operations (resulting in green intervals) to match the string {\sf GTATG} with $k=4$ against a reference $\mathcal{S}= \{${\sf TGTTTG}, {\sf TTGCTAT}, {\sf ACGTAGTATAT}, {\sf TGTAAA}$\}$. This match produces the matching statistics vector $MS=\{ 1, 2, 3, 4, 2 \}$ and derandomizes to the vector $DMS=\{ 1, 2, 3, 4, 0 \}$ if the threshold used is $t = 2$.
    }
    \label{fig:sbwt-search}
\end{figure*}

\subsection{Preliminaries}\label{preliminaries}

{\sf kbo} is implemented on top of state-of-the-art string processing data structures and algorithms. In this section, we give an overview of the machinery we use to compute the $k$-bounded matching statistics for {\sf kbo}. We provide only the key definitions necessary to be able to talk about the data structures on a technical level; the motivation and theory behind the definitions are described in detail in prior work~\cite{alanko2023longest, alanko2024finimizers, alanko2023small}.



%that lie at the heart {\sf kbo}. 

%The SBWT essentially sorts the last characters of the distinct $k$-mers in the input by the \emph{colexicographic} (right-to-left lexicographic) order of their prefixes of length $k-1$. 
The main workhorse of {\sf kbo} is the Spectral Burrows-Wheeler transform (SBWT) data structure. Roughly speaking, the SBWT lists the sets of outgoing edge labels from nodes in the de Bruijn graph of the input $k$-mers, such that these sets are sorted by the \emph{colexicographic} (right-to-left lexicographic) order of the $k$-mers on the nodes.

To give the precise definition, we need to introduce the concept of the \emph{padded $k$-spectrum}. First, the $k$-spectrum of a string is the set of distinct $k$-mers in the string.

\begin{definition}($k$-Spectrum) The $k$-spectrum $\mathcal{S}_k(S)$ of string $S$ is the set of distinct $k$-mers $\{S[i..i+k-1] \; | \; i = 1 , \ldots, |S|-k+1\}$.
%\end{definition}
%
%\begin{definition}($k$-Spectrum of a set of strings) 
The $k$-spectrum $\mathcal{S}_k(S_1, \ldots, S_m)$ of a set of strings $S_1, \ldots, S_m$ is the union $\bigcup_{i = 1}^m \mathcal{S}_k(S_i)$.
\end{definition}

\noindent Informally, a \emph{padded $k$-spectrum} adds a minimal set of $\$$-padded \emph{dummy} $k$-mers to ensure that in the de Bruijn graph of $\mathcal S_k(S_1, \ldots, S_m)$ and the dummy $k$-mers, every non-dummy $k$-mer has an incoming path of length at least $k$.

\begin{definition}\label{def:padded_k_spectrum} (Padded $k$-Spectrum)
Let $R = \mathcal{S}_k(S_1, \ldots, S_m)$ be a $k$-spectrum with alphabet $\Sigma$, and let $R' \subseteq R$ be the set of $k$-mers $Y$ such that $Y[1..k-1]$ is not a suffix of any $k$-mer in $R$. The padded $k$-spectrum is the set $\mathcal{S}_k^+(S_1, \ldots, S_m) = R \cup \{\$^k\} \cup \bigcup_{Y \in R'} \{\$^{k-i} Y[1..i] \; | \; i = 1, \ldots, k-1\}$, with special character $\$ \not\in \Sigma$ and $\$ < c$ for all $c \in \Sigma$.
\end{definition}
\noindent For example, if $S_1 = $ {\sf ACGT}, $S_2 = $ {\sf GACG} and $k=3$, then $\mathcal{S}_3(X_1, X_2) = \{ {\sf ACG }, {\sf CGT }, {\sf GAC }\}$ and $\mathcal{S}_3^+(X_1, X_2) = $ $\{{\sf ACG }, {\sf CGT}, {\sf GAC }, {\sf \$\$\$}, {\sf \$\$G}, {\sf \$GA} \}$.

We are now ready to define the SBWT.

\begin{definition}\label{def:SBWT}(Spectral Burrows-Wheeler transform (SBWT)~\cite{alanko2023small}) Let $R^+$ be a padded $k$-spectrum and let $S_1, \ldots, S_{|R|}$ be the elements of $R^+$ in colexicographic order. The SBWT is the sequence of sets $A_1, \ldots, A_{|R|}$ with $A_i \subseteq \Sigma$ such that $A_i = \emptyset$ if $i > 1$ and $S_i[2..k] = S_{i-1}[2..k]$, otherwise $A_i = \{c \in \Sigma \; | \; S_i[2..k]c \in R^+\}$.
\end{definition}
\noindent We refer the reader to~\cite{alanko2023longest, alanko2024finimizers, alanko2023small} for examples. The Longest Common Suffix array is the key to efficient computation of the $k$-bounded matching statistics (to be defined later in this section):

\begin{definition}\label{def:LCS-array}(Longest Common Suffix ($LCS$) Array~\cite{alanko2023longest})     
Let $R^+$ be a padded $k$-spectrum and let $X_i$ be the colexicographically $i$-th $k$-mer of $R^+$. 
The $LCS$ array is an array of length $|R^+|$ s.t. $LCS[1] = 0$, and for $i > 1$, $LCS[i]$ is the length of the longest common suffix of $S_{i-1}$ and $S_i$.
\end{definition}
 In the above definition, we consider the empty string as a common suffix of any two $k$-mers, so that the longest common suffix is well-defined for any pair of $k$-mers.
An example of a $LCS$ array is shown in Figure~\ref{fig:sbwt-search}.

When the $k$-mers in $R^+$ are sorted colexicographically, the subset of $k$-mers in $R^+$ that share a string $\alpha$ as a suffix are next to each other. This is called the \emph{colexicographic range} of $\alpha$. The colexicographic range of a string $\alpha$ that is \emph{longer} than $k$ is defined as the range of $k$-mers in the sorted list of $R^+$ that have the last $k$ characters of $\alpha$ as a suffix. The SBWT provides two operations on colexicographic ranges $[\ell, r]$ of any string $\alpha$: 

\begin{itemize}
\item ExtendRight($\ell, r, c$) returns the colexicoraphic range of string $\alpha c$ (possibly an empty range).
\item ContractLeft($\ell, r$), with $[\ell, r]$ being the colexicographic range of $\alpha$, returns the colexicographic range of $\alpha[2..|\alpha|]$.
%defined only if $|\alpha| \geq 1$, returns the colexicographic range of $\alpha[2..|\alpha|]$ if $|\alpha| >1$ or $R^+$ if $|\alpha|=1$. \textcolor{red}{TODO:can we write this better? longest proper suffix of $\alpha$ if it exists, $R^+$ otherwise?}
\end{itemize}

See Alanko et al. \cite{alanko2024finimizers} for details on how to implement these operations using the SBWT. Figure~\ref{fig:sbwt-search} provides an illustration of both operations.

%\subsection{\texorpdfstring{$k$-bounded matching statistics}{k-bounded matching statistics}}

The $k$-bounded matching statistics are defined as follows:

\begin{definition}\label{def:k-bounded-ms}
    ($k$-bounded matching statistics \cite{alanko2024finimizers})
    The $k$-bounded matching statistics for a query string $Q$ against a set of reference strings $S_1, \ldots, S_m$ is a vector $MS_k[1..|Q|]$ such that $MS_k[i]$ is the largest integer $l \leq k$ such that $Q[i-l+1..i]$ %\textcolor{red}{$Q[i..i-d+1]$ this is not a suffix ending in i}
    is a substring of at least one reference $S_1, \ldots, S_m$.
\end{definition}

In what follows, we may drop the subscript of $MS_k$ since $k$ is assumed constant throughout the paper.

The padded $k$-spectrum $R^+$ provides an equivalent and formulation that is easier to compute: the value of $MS[i]$ is the length $l$ of the longest \emph{suffix of a $k$-mer} in the padded spectrum of $T_1, \ldots, T_m$ that matches $Q[i-l+1..i]$. The $k$-mers in $R^+$ that have suffix $Q[i-l+1..i]$ are adjacent in the colexicographically sorted list of $k$-mers in $R^+$ (the colexicographic range of $Q[i-l+1..i]$). Algorithm \ref{alg:MS} shows pseudocode to compute the MS vector and the colexicographic ranges $[\ell, r]$ corresponding to the longest match at each position.

\begin{algorithm}
\begin{algorithmic}[1]
\small
\Require A query string $Q$ and a data structure supporting $ExtendRight$ and $ContractLeft$ on the padded $k$-mer spectrum. %in constant time. \\
\Ensure $MS_k[1..|Q|]$
\State $\ell, r \gets [1,n]$ \Comment{The current colexicographic range}
\State $l \gets 0$ \Comment{The length of the current match, up to $k$}
\State $MS_k[1..|Q|] \gets $ Array of length $|Q|$.
\For{$i = 1..|Q|$}
\While{$l > 0 \textbf{ and } ExtendRight(\ell, r, Q[i]) = \emptyset$}\label{line:MS-1-start}
    \State $\ell, r \gets ContractLeft(\ell, r)$
    \State $l \gets l-1$
\EndWhile \label{line:MS-1-end}
\If{$ExtendRight(\ell, r, Q[i]) \neq \emptyset$}
    \State $\ell, r \gets ExtendRight(\ell, r, Q[i])$\label{line:MS-2-start}
    \State $p \gets \min(k, l+1)$\label{line:MS-2-end}
\EndIf
\State $MS_k[i] \gets l$ %\Comment{The frequency of the match is $r - \ell + 1$} 
\label{line:MS-4-assignment}
\EndFor
\caption{\small $k$-bounded matching statistics.} 
\label{alg:MS}
\end{algorithmic}
\end{algorithm}

\subsection{Identifying statistically significant match positions}\label{sec:random-match-model}
For each query $Q$, we use Algorithm \ref{alg:MS} to compute the matching statistics vector $MS_k[1..|Q|]$. The matching statistic $MS_k[i]$ is the length of the longest match ending at position $i$ in $Q$, up to length $k$ (See Definition \ref{def:k-bounded-ms}). Even a random query will likely match some number of nucleotides at every position by chance alone. Our goal in this section is to derive a threshold for a statistically significant match length.

This threshold must be a function of the number of $k$-mers in the index: the larger the amount of indexed data, the longer matches we expect to find by chance. Let us denote the set of $k$-mers in the index with $\mathcal I$. We use a model where all the $k$-mers in $\mathcal I$ are independent random strings. The match length distribution at a given position against a single random $k$-mer follows a geometric distribution truncated at $k$. To simplify the formulas, we assume an untruncated geometric distribution. This is reasonable since for values $k \geq 30$ that we use, a full $k$-mer match is extremely unlikely. With these assumptions, if $X$ is the random variable denoting the length of the match against a single $k$-mer, the cumulative distribution $P(X \leq t)$ is given by:

\begin{equation}
    P\left(X \leq t\right) = 1 - p^{t + 1},
\label{geom-distribution}
\end{equation}
where $p$ is the probability that two nucleotides match by chance, e.g. $p = 1/4$. Now, let $M$ be a random variable denoting the length of the longest suffix match ending at some position $Q[i]$ against the entire index $\mathcal{I}$ containing $n$ distinct $k$-mers. Since the $k$-mers in $\mathcal I$ are assumed to be independent, the CDF of the maximum match length is:

%Since distribution of the longest common prefix of the query string $S_k$ and any string $S_i \in \mathcal{I}$ from the index $\mathcal{I}$ is given by the random variable $\mathcal{X}$, 
%we can define a new random variable $\mathcal{M}$ 
%which is the maximum of $n$ independent random variables with the same distribution as 
%$\mathcal{X}$ by setting 
%$\mathcal{M} = \text{max}\left\{\mathcal{X}_1, \text{\textellipsis}, \mathcal{X}_n\right\}$. 
%Because the variables $\mathcal{X}$ were assumed independent, the CDF of $\mathcal{M}$ is the product of $n$ random variables with the cumulative distribution function from Equation (\ref{geom-distribution})

\begin{equation}
    P\left(M \leq t\right) = P\left(X \leq t\right)^n = \left(1 - p^{t + 1}\right)^n
\label{max-of-geom-distributions}    
\end{equation}
Suppose we want to consider a match as statistically significant if it occurs with probability at most $r$ in our model. We can determine the corresponding match length $t_p$ by setting the CDF in Equation \ref{max-of-geom-distributions} to greater than $1-r$ and solving for $t$. We obtain:

\begin{equation}\label{analytic_noise_treshold}
t_p \geq \frac{\log (1 - (1-r)^{1/n})}{\log p} - 1\;,
\end{equation}
For example, for a small genome with $n = 10^6$ distinct $k$-mers,  nucleotide match probability $p = 0.25$ and false positive tolerance $r = 10^{-6}$, we have $t_p \approx 18.9$.

\subsection{\texorpdfstring{Derandomizing $k$-bounded matching statistic vectors}{Derandomizing k-bounded matching statistic vectors}}


\begin{figure}[b]
    \centering
    \includegraphics[width=1.0\linewidth]{fig/derandomized_MS.drawio.pdf}
    \caption{Derandomizing the MS vector. The y-axis is the length of a match ending at a given position in the query (the x-axis). The dashed horizontal line is the noise threshold. The dotted line shows the derandomized values. }
    \label{fig:derandomization}
\end{figure}
Using the threshold $t_p$ from Equation (\ref{analytic_noise_treshold}), we \emph{derandomize} $MS_k$ by replacing match lengths below the threshold $t_p$ with values derived from nearby values. A key fact to understand about the $MS_k$ vector is that always $MS[i]$ at most $MS[i-1]+1$. For typical real data, the general shape of the $MS_k$ vector is a mountainscape with slow climbs and sharp falls, interspersed with with noisy valleys below the significant match threshold (see Figure \ref{fig:derandomization}). The idea of derandomization is to extrapolate the climbs backward to eliminate the noisy segments. The process is detailed in Algorithm \ref{alg:derandomized-MS}. After this processing, we can easily read off the lengths of gaps in the matches, as shown in the next section.

\begin{comment}
    version $d = d_1, \dots, d_N$ of the matching statistics vector $MS$ by iterating over $MS$ in reverse and applying the following procedure on the elements $MS[n] = ms_N, \dots, ms_1$
\begin{enumerate}
\item If $MS[n] > t_p$ and $MS[n+1] < MS[n]$,  then $d_n = MS[n]$,
\item If $MS[n] = k$, then $d_n = k$,
\item By default $d_n = MS[n+1] - 1$
\end{enumerate}
\end{comment}

%TODO ref to alg below



\begin{algorithm}[t]
\begin{algorithmic}[1]
\small
\Require Matching statistics vector $MS_k[1..n]$, significant match threshold $t_p$ from Equation \ref{analytic_noise_treshold}.
\Ensure Derandomized MS vector $DMS_k[1..n] = (d_1, \ldots, d_{n})$.
\State $DMS_k \leftarrow $ Array of length $n$ initialized to zeros
\State $DMS_k[n] \gets MS_k[n]$
\For{$i = 1..n-1$ in reverse order}
\If{$MS_k[i] = k$}
\State $DMS_k[i] \gets k$
\ElsIf{$MS_k[i] \geq t_p$ and $MS[i+1] > MS[i]$}
    \State $DMS_k[i] \gets MS_k[i]$
\Else
    \State $DMS_k[i] \gets DMS_k[i+1]-1$
\EndIf
\EndFor
%\State \Return $DMS$
\caption{\small Derandomizing the MS vector} 
\label{alg:derandomized-MS}
\end{algorithmic}
\end{algorithm}

\subsection{Translating derandomized matching statistics into alignment events}
 


%Zeros in $d$ mark the first base after end of a match, and negative values denote 0-indexed distance from the last matching base. The key to this simple procedure is reading the matching statistics vector $MS$ in reverse and using the threshold $t_p$ to determine when a new match begins after a gap.


The derandomized MS vector can be translated into a character representation of the compatibility between the query and a reference sequence. For example, a single nucleotide substitution or insertion at position $i$ will show up as run from 0 to $k$ in $DMS_k[i..i+k]$. These can be distinguished from deletions and recombinations, which exhibit different kinds of characteristic patterns. All the possible cases are displayed in Figure \ref{fig:translate_cases}a. We represent character compatibility events using the following set of symbols:

\input{translatingDMS}
\begin{comment}
The translation $t_n$ for each value in the derandomized MS vector $d_n$ depends on the neighboring values $d_{n - 1}$, $d_{n + 1}$ and the threshold $t_p$. We use the following algorithm to determine the character representation of the events
    \begin{enumerate}
\item If $d_n > t_p$ and $d_{n + 1} > 0$ and $d_{n + 1} < t_p$, \\ then $t_n = \text{'R'}$ and $t_{n + 1} = \text{'R'}$.
\item If $d_n <= 0$, then there is a mismatch in the query and we apply
    \begin{enumerate}
    \item If $d_{n + 1} = 1$ and $d_{n - 1} > 0$, then $t_n = \text{{\tt X}}$.
    \item Else $t_n = \text{'-'}$.
    \end{enumerate}
\item By default $t_n = \text{'M'}$
\end{enumerate}
\end{comment}

\begin{enumerate}
\item[\textbf{$\tt{M}$}]: Match between query and reference.
\item[\textbf{-}]: Bases in the query that are not found in the reference.
\item[\textbf{$\tt{X}$}]: Single base mismatch \textit{or} single base insertion into the query.
\item[\textbf{$\tt{R}$}]: Two consecutive ${\tt R}$s signify a discontinuity in the alignment. The right ${\tt R}$ is at the start of a $k$-mer that is not adjacent to the last character in the $k$-mer corresponding to the left ${\tt R}$. This implies either a deletion of unknown length in the query, or an insertion of $k$-mers from elsewhere in the reference into the query.
\end{enumerate}
Algorithm \ref{alg:tranlating-DMS} shows how these events can be detected with a single backward pass over the $DMS_k$ array. Figure \ref{fig:translate_cases}b shows an example where all the cases occur in a single query. Note how this example illustrates that the procedure is not able to distinguish between a single base insertion and a single base substitution. This problem can be resolved by adding a \textit{refinement} step to our translation, which resolves this conundrum by using the nucleotide sequence of the reference.

\subsection{Filling gaps in the translated alignment}
Translated output from {\sf kbo} may contain gaps that are falsely marked as so. These are primarily caused by multiple changes occurring within an interval shorter than the \emph{k}-mer size, which leads the derandomization algorithm to mark the entire interval as a gap. Gaps that can be overlapped by a single \emph{k}-mer resolve with use of the variant calling, but if a single \emph{k}-mer is not enough a dedicated gap filling procedure is needed.

We start by defining the \textit{nearest unique context} of a gap. The nearest unique context $\nu$ is the colexicographic range $\left[l,r\right]$ with size $r - l = 0$ of a \emph{k}-mer $k_\nu$ whose suffix matches the characters to right of the gap. We require at least the derandomization threshold $t_p$ long suffix matches to avoid spurious \emph{k}-mers. This implies that $k_\nu$ ends at most $k - t_p$ characters to right of the gap. The first step in our gap filling algorithm is to search for the nearest unique context and, if it does not exist, the gap is considered unfillable.

If $k_\nu$ exists, we search the LCS array for left extensions $\lambda_i$ of $k_\nu$ until the prefix of $\lambda_i$ matches the sequence left of the gap by $t_p$ characters. At each left extension, the concatenated sequence $\alpha_i = \left[\lambda_i, k_\nu\right]$ must have a colexicographic range with size $0$. Note that $k_\nu$ may already fulfil these criteria if the gap is shorter than $k - 2*t$, in which case $\lambda_\nu$ is an empty sequence.

\begin{figure}[t]
    \centering
    
    {\includesvg[width=1.0\linewidth]{fig/kbo_translate_cases.svg}}
    \caption{Illustration of the results of applying the translation procedure to a derandomized matching statistics vector. Examples in both panels assume \emph{k}-mer size 3 and derandomization threshold $t=2$. MS is short for matching statistics and DMS for derandomized matching statistics.}
    \label{fig:translate_cases}
\end{figure}

After finding a valid left extension $\lambda_\nu$, we determine whether to fill the gap with $\beta_\nu = \left[\alpha_{\nu,t_p + 1},\dots,\alpha_{\nu,N - t_p - 1}\right]$, where $N$ is the total size of $\alpha_\nu$, by applying a series of checks. The first check is that the size of $\beta_\nu$ must equal the size of the gap, meaning there are no insertions or deletions in $\beta_\nu$. The second check is that $\beta_\nu$ must meet at least one of the following three requirements: 1) $\lambda_\nu$ is an empty sequence, 2) all characters in $\beta_\nu$ except $\alpha_{t_p + 1}$ and $\alpha_{N - t_p - 1}$ match the reference, or 3) the probability of generating all consecutive matches in $\beta_\nu$ is less than $t_p$. We compute 3) using products of the CDF of maximum match lengths (Definition \ref{max-of-geom-distributions}). If the checks pass, we consider $\beta_\nu$ valid and fill the gap with its characters.

\subsection{Variant calling using matching statistics}
\textcolor{red}{TODO write}

\subsection{Implementation}
We provide {\sf kbo} in the form of three software packages written fully in the Rust programming language: kbo\footnote{\url{https://github.com/tmaklin/kbo}} contains the implementations of our algorithms and is intended for usage in other programs, kbo-cli\footnote{\url{https://github.com/tmaklin/kbo-cli}} provides a command-line client, and kbo-gui\footnote{\url{https://github.com/tmaklin/kbo-gui}} is a Rust-to-WebAssembly graphical user interface that runs in a browser with no server-side processing or data transfer. Both the command-line and graphical user interfaces provide full access to all features of {\sf kbo}. An overview of the operation of {\sf kbo} is given in Figure \ref{fig:kbo-overview}

\begin{figure*}[!t]%
\centering
{\includesvg{fig/kbo_overview.svg}}
\caption{Overview of the three main algorithms in {\sf kbo}: find, call, and map. The figure shows which parts of the sbwt and {\sf kbo} core libraries each algorithm makes use of and illustrates example inputs and outputs to and from the user interface implementations. }\label{fig:kbo-overview}
\end{figure*}


\section{Use cases}
We demonstrate {\sf kbo} on three common bacterial genomics tasks and present results for both accuracy and compute resource usage. These demonstrations were conducted using the command-line interface (kbo-cli v0.2.0) running on a 2021 Dell XPS 13 laptop with an Intel i7-1165G7 4-core processor and 16GB RAM. All tools were ran with the default parameters unless otherwise stated. A Docker container that reproduces the results is available from \textcolor{red}{TODO Add the container somewhere.}.

\subsection{Variant calling with 'kbo call'}
\begin{figure}
    \centering
    \includegraphics[width=1.0\linewidth]{fig/variant_calling_resource_consumption.pdf}
    \caption{Resource consumption in variant calling for the four tested methods kbo, MUMmer4, Shred, and SKA. Panel a) shows a boxplot of time taken to process each sample. Panel b) the peak memory usage during each run, and Panel c) the temporary disk requirement. The thick lines denote the median and the whiskers the 25\% and 75\% quantiles.}
    \label{fig:vc-resource-usage}
\end{figure}

\begin{table}[]
\begin{tabular}{lrrrrr}
Method & TP  & FN  & FP   & Sensitivity & Precision \\
\hline
kbo    & 782 & 0   & 1630 & 1.00    & 0.32  \\
MUMmer4 & 782 & 0   & 4669 & 1.00    & 0.14  \\
shred  & 782 & 0   & 4001 & 1.00    & 0.16  \\
SKA    & 374 & 408 & 7431 & 0.48    & 0.05
\end{tabular}
\caption{Accuracy in resolving single-nucleotide substitutions across four tested methods. The ground-truth was determined with read-based variant calling against a hybrid-assembled reference genome. Values are rounded to 2 most significant digits.}
\label{vc-snps}
\end{table}
\begin{table}[]
\begin{tabular}{lrrrrr}
Method & TP & FN & FP  & Sensitivity & Precision \\
\hline
kbo    & 68 & 0  & 190 & 1.00    & 0.26  \\
MUMmer4 & 68 & 0  & 719 & 1.00    & 0.09  \\
shred  & 68 & 0  & 699 & 1.00    & 0.09  
\end{tabular}
\caption{Accuracy in resolving insertions and deletions across three tested methods. SKA does not resolve insertions and deletions so it is omitted. The ground-truth was determined with read-based variant calling against a hybrid-assembled reference genome. Values are rounded to 2 most significant digits.}
\label{vc-indels}
\end{table}

We benchmarked the variant calling algorithm in {\sf kbo} by reproducing an experiment conducted in an earlier study \cite{wick2025reads}. Briefly, in this study seven very closely related (less than 10 nucleotides difference) \textit{Staphylococcus aureus} assemblies were created with different assemblers and sequencing technologies, including short-read and long-read sequencing of the same isolates. The study compared variant calls obtained from assemblies only against the gold standard read-based calls on a hybrid-assembled 2.9Mb long reference genome. We compare the variant calls from {\sf kbo} against calls generated using tools based on either genome alignment (MUMmer4\cite{marccais2018mummer4}), a pipeline converting the assemblies into pseudo reads using wgsim, aligning them against the reference with bwa-mem \cite{li2013aligning}, and calling the variants with freebayes \cite{garrison2012haplotype} (called shred, a similar pipeline is implemented in Snippy \cite{seemann2015snippy}), and a split \emph{k}-mer based approach (SKA \cite{derelle2024seamless}).

Our results (Tables \ref{vc-snps} and \ref{vc-indels}) show that like MUMmer4 and shred, {\sf kbo} achieves perfect sensitivity and successfully calls all SNPs and INDELs that are present in the gold standard. When measured by precision, {\sf kbo} is markedly better at reporting fewer false positives, achieving two times better precision in SNP calling and three times better in resolving INDELs. Supplementary figure (supplement\_vc\_parameter\_effects.pdf) shows how the results from {\sf kbo} change when the \emph{k}-mer size and the maximum error probability parameters are varied.

By resource usage {\sf kbo} is the fastest method, taking an average of 1.6s seconds to process a single pairwise comparison (Fig. \ref{fig:vc-resource-usage}a). The peak memory usage of {\sf kbo} is comparable to the other \emph{k}-mer based method, SKA, requiring 401MB per comparison on average (Fig. \ref{fig:vc-resource-usage}b). Since {\sf kbo} performs all operations fully in-memory, the tool is the only one of the four tested that requires no temporary disk space (Fig. \ref{fig:vc-resource-usage}c). Overall the resource usage of {\sf kbo} is mainly determined by the \emph{k}-mer size parameter and we have included a supplementary figure showing how the runtime and memory usage change with different values of \emph{k} (variant\_calling\_kmer\_size\_effect.pdf).

\subsection{Gene finding with 'kbo find'}
The 'find' command in {\sf kbo} can be used to find the coordinates of some reference sequence(s) of interest in a query. In this example we demonstrate an use case for 'find' in locating 19 genes (total 50 000 bases long) belonging to the pks pathogenicity island in 1 999 \textit{E. coli} chromosome sequences (avg. length 4.63Mb) from the Norwegian surveillance programme on resistant microbes (NORM) collection \cite{gladstone2021emergence, arredondo2023escherichia}.

The ground truth was generated by annotating the 1 999 assemblies with bakta \cite{schwengers2021bakta}. Reference sequences for the pks island genes were extracted from the \textit{E. coli} IHE3034 strain (\href{https://www.ebi.ac.uk/ena/browser/view/GCA_000025745.1}{ASM2574v1A}) \cite{moriel2010identification}. Assemblies were processed in four parallel processes with a single thread each using the GNU parallel tool \cite{tange_2024_13826092}, taking a total of 509 seconds (0.25s per assembly) and 195MB peak memory. For comparison, running the same analysis with blast+ \cite{camacho2009blast+} takes 364 seconds (0.18s per assembly) and 189MB peak memory. Our tool was able to identify the exact same regions as bakta in 894 out of 934 assemblies. In the remaining 39 assemblies, the average difference between alignments reported by {\sf kbo} and the gene annotations from bakta was 5 bases out of the total 50 000.

The default mode for 'find' does not report the name of the reference sequence (gene or contig for example) that an alignment was found in due to limitations the matching statistics algorithm. If the names are required, we implement a detailed mode that indexes each sequence separately, overcoming this problem. The detailed mode is significantly slower, taking a total of 6 540 seconds (3.3s per assembly) and 1417MB peak memory to run the same experiment. We leave a more efficient algorithm to future work.

\subsection{Reference-based alignment with 'kbo map'}

The final operation supported by {\sf kbo} is reference-based alignment of two assemblies, where the nucleotides in a query sequence are mapped relative to a reference sequence. The results of this procedure are useful in, for example, phylogenetic inference when the original sequencing reads are not available or the number of queries is prohibitively large for storing the read data. We created a benchmark for 'kbo map' by extracting the short-read sequencing data and 112 fully assembled chromosome sequences from \textit{E. coli} sequence type (ST) ST131 isolates in the previously mentioned NORM collection \cite{gladstone2021emergence,arredondo2023escherichia}. The ground truth was inferred by selecting a random hybrid assembly as the reference, aligning paired-end short-read sequencing reads from the other isolates against it using bwa-mem2 \cite{vasimuddin2019efficient}, and using samtools \cite{10.1093/gigascience/giab008} to convert the alignment into a consensus sequence.

\begin{table}[]
\begin{tabular}{lrrr}
Method & 25\%-q.  & Median  & 75\%-q. \\
\hline
kbo    & 29 690 & 73 814   & 84 420  \\
SKA    & 78 547 & 104 990 & 117 813 \\
Snippy  & 124 386 & 149 894 & 159 206  \\
\end{tabular}
\caption{Absolute errors (base pairs) in reference-based alignment of 112 \textit{E. coli} chromosome sequences across kbo, SKA and Snippy.}
\label{map-absolute-error}
\end{table}
\begin{table}[]
\begin{tabular}{lrrr}
Method & 25\%-q.  & Median  & 75\%-q. \\
\hline
kbo    & 0.6\% & 1.5\% & 1.7\%  \\
SKA    & 1.6\% & 2.1\% & 2.4\% \\
Snippy  & 2.5\% & 3.0\%   & 3.2\%  \\
\end{tabular}
\caption{Relative errors (\% of reference length) in reference-based alignment of 112 \textit{E. coli} chromosome sequences across kbo, SKA and Snippy. The reference sequence length was 5 025 582 base pairs.}
\label{map-relative-error}
\end{table}

We compared the accuracy of 'kbo map' to two other tools, SKA\cite{derelle2024seamless} and Snippy\cite{seemann2015snippy}, and the ground truth by measuring the results (A, C, G, T, and ambigious or gap) in the alignment that agree or disagree between the tested tools and the ground truth. The results were obtained by aligning query hybrid assemblies against the reference sequence, disregarding the sequencing reads. Our results show that all three tools have comparable accuracy, with {\sf kbo} being slightly better when measured by median errors (Tables \ref{map-absolute-error}, \ref{map-relative-error}). Figure \ref{fig:map-by-kmer-size}c shows how the accuracy of {\sf kbo} changes when the \emph{k}-mer size and error probability parameters are varied.

\begin{figure}
    \centering
    \includegraphics[width=1.0\linewidth]{map_parameter_comparison.pdf}
    \caption{Resource usage and accuracy of 'kbo map' in reference-based alignment of 112 \textit{E. coli} ST131 chromosome sequences with different parameter configurations. Panel a) shows a boxplot of runtimes of each sequence, Panel b) peak memory usage, and Panel c) accuracy measured as number of incorrect base pairs out of the 5 025 582 reference base pairs. The boxes are coloured by the maximum error probability parameter used.}
    \label{fig:map-by-kmer-size}
\end{figure}


In resource usage {\sf kbo} and SKA were comparable, with {\sf kbo} total 624 seconds (mean 5.7s per assembly) and 655MB peak memory to process the benchmark and SKA 669 seconds (6.0s per assembly) and 830MB peak memory. The slowest tool was Snippy which took 2 361 seconds (21.1s per assembly) but had a lower peak memory consumption at 385MB. Additionally, SKA and Snippy used a maximum of 29MB and 52MB temporary disk space, respectively, during the benchmark. The resource usage of {\sf kbo} is primarily determined by the \emph{k}-mer size parameter (Figures \ref{fig:map-by-kmer-size}a and \ref{fig:map-by-kmer-size}b) and whether further refinmenet with the gap filling and variant calling algorithms are used. Taken together, {\sf kbo} was the fastest and most accurate method in this benchmark.

\subsection{Running kbo in the browser}
In addition to the command-line client, we also provide a WebAssembly version of {\sf kbo} that runs entirely in the browser and does not send any user data to a remote server. The web version of {\sf kbo} allows users without command-line familiarity to access the tool on any device that with support for a modern browser and modest compute power. Thanks to the frugal resource usage of {\sf kbo}, the web version supports all functionality provided by the command-line client and can be used to perform any of the analyses presented in this paper. A demonstration of the web version is available online\footnote{\url{https://maklin.fi/kbo}} and can easily be deployed on any web server that supports serving WebAssembly files.

\section{Discussion \textcolor{red}{Draft todo finish}}

Plain \emph{k}-mer matching methods typically do not support retrieval of the coordinates of the matches. We resolved this problem by augmenting \emph{k}-mer matching with \emph{k}-bounded matching statistics, allowing us to transform the matching results into a format where location data can be inferred with high accuracy and converted into local alignment data. Our results show that in addition to being competitive with state-of-the-art methods in accuracy, our approach retains the attractive rapid lookups enabled by the specialized data structures for indexing \emph{k}-mers, making it a novel and practically feasible alternative to existing local alignment methods.

One of the two main disadvantages of our method is the comparatively high space usage, especially for large values of k, required for constructing the \emph{k}-mer index to perform queries. This issue plagues most \emph{k}-mer indexing methods, as the index size is proportional to the number of unique \emph{k}-mers in the input. Index construction algorithms often rely on streaming from temporary disk space to reduce the space usage but we opted for indexing fully in-memory to enable the browser implementation and make our methods better suited for high-performance computing usage, where disk throughput is a limiting factor for parallelisation.

The other future area of improvement is extending matching statistic computation to support coloured index structures, where each \emph{k}-mer in the index is accompanied by a colour that denotes its sequence of origin. Storing distinct sequences in this manner would enable efficient indexing of many closely related sequences using colourset compression and open up developing {\sf kbo} towards aligning sequencing reads against large reference collections where it is important to know which targets the read aligned against. The SBWT data structure already supports colours but an algorithm for coloured matching statistics remains elusive. We leave support for sequencing read alignment and coloured matching statistics to future work.

To our knowledge, {\sf kbo} is the first sequence aligner that compiles to WebAssembly and allows running all features of the tool in a browser including using custom indexes. Web tools have found wide adoption among applied researchers but they remain difficult to customise and require server-side processing, which comes with privacy and long-term support concerns. Using WebAssembly alleviates all of these issues, as the codebase becomes much simpler without a separate client-server model and no data transfer taking place beyond serving the executable to the user. We have made the source code for all parts of our implementation freely available and expect that they will facilitate future implementations of customised analysis pipelines in a manner that is accessible to both non-experts and bioinformaticians alike.


\section{Code availability}
The Rust library, command-line interface, and graphical user interface implementing the methods described here are freely available from GitHub \url{https://github.com/tmaklin/kbo} and Codeberg \url{https://codeberg.org/themaklin/kbo} under a MIT and Apache 2.0 dual license.

\section{Competing interests}
No competing interest is declared.

\section{Author contributions statement}
T.M. designed the core kbo algorithms and implemented the kbo, kbo-cli, and kbo-gui Rust libraries. J.N.A. implemented the sbwt Rust library and derived the random match distribution. J.N.A. and E.B. designed and implemented the variant calling algorithm. T.M., J.N.A, E.B., and S.J.P. investigated the relationship between \emph{k}-bounded matching statistics and local alignments. S.J.P. obtained funding and supervised the study. All authors contributed to the writing, reviewing, and editing of the manuscript.

\section{Acknowledgments}
This work was supported in part by the Research Council of Finland via grant 351150.

%\input{fig/figure_translate_cases_a}
%\input{fig/figure_translate_cases_b}


\bibliographystyle{plain}
\bibliography{reference}


%USE THE BELOW OPTIONS IN CASE YOU NEED AUTHOR YEAR FORMAT.
%\bibliographystyle{abbrvnat}
%\bibliography{reference}

\end{document}
