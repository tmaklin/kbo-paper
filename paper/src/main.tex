%%
%% Copyright 2022 OXFORD UNIVERSITY PRESS
%%
%% This file is part of the 'oup-authoring-template Bundle'.
%% ---------------------------------------------
%%
%% It may be distributed under the conditions of the LaTeX Project Public
%% License, either version 1.2 of this license or (at your option) any
%% later version.  The latest version of this license is in
%%    http://www.latex-project.org/lppl.txt
%% and version 1.2 or later is part of all distributions of LaTeX
%% version 1999/12/01 or later.
%%
%% The list of all files belonging to the 'oup-authoring-template Bundle' is
%% given in the file `manifest.txt'.
%%
%% Template article for OXFORD UNIVERSITY PRESS's document class `oup-authoring-template'
%% with bibliographic references
%%

%%%CONTEMPORARY%%%
\documentclass[unnumsec,webpdf,contemporary,large]{oup-authoring-template}%
%\documentclass[unnumsec,webpdf,contemporary,large,namedate]{oup-authoring-template}% uncomment this line for author year citations and comment the above
%\documentclass[unnumsec,webpdf,contemporary,medium]{oup-authoring-template}
%\documentclass[unnumsec,webpdf,contemporary,small]{oup-authoring-template}

%%%MODERN%%%
%\documentclass[unnumsec,webpdf,modern,large]{oup-authoring-template}
%\documentclass[unnumsec,webpdf,modern,large,namedate]{oup-authoring-template}% uncomment this line for author year citations and comment the above
%\documentclass[unnumsec,webpdf,modern,medium]{oup-authoring-template}
%\documentclass[unnumsec,webpdf,modern,small]{oup-authoring-template}

%%%TRADITIONAL%%%
%\documentclass[unnumsec,webpdf,traditional,large]{oup-authoring-template}
%\documentclass[unnumsec,webpdf,traditional,large,namedate]{oup-authoring-template}% uncomment this line for author year citations and comment the above
%\documentclass[unnumsec,namedate,webpdf,traditional,medium]{oup-authoring-template}
%\documentclass[namedate,webpdf,traditional,small]{oup-authoring-template}

%\onecolumn % for one column layouts

%\usepackage{showframe}

\graphicspath{{fig/}}

% svg images
\usepackage[inkscapelatex=false]{svg}

% line numbers
%\usepackage[mathlines, switch]{lineno}
%\usepackage[right]{lineno}

\theoremstyle{thmstyleone}%
\newtheorem{theorem}{Theorem}%  meant for continuous numbers
%%\newtheorem{theorem}{Theorem}[section]% meant for sectionwise numbers
%% optional argument [theorem] produces theorem numbering sequence instead of independent numbers for Proposition
\newtheorem{proposition}[theorem]{Proposition}%
%%\newtheorem{proposition}{Proposition}% to get separate numbers for theorem and proposition etc.
\theoremstyle{thmstyletwo}%
\newtheorem{example}{Example}%
\newtheorem{remark}{Remark}%
\theoremstyle{thmstylethree}%
\newtheorem{definition}{Definition}


\begin{document}

\journaltitle{Journal Title Here}
\DOI{DOI HERE}
\copyrightyear{2022}
\pubyear{2019}
\access{Advance Access Publication Date: Day Month Year}
\appnotes{Paper}

\firstpage{1}

%\subtitle{Subject Section}

\title[Local alignment with kbo]{Local alignment search with \textit{k}-bounded matching statistics}

\author[1,$\ast$]{Tommi M\"{a}klin\ORCID{0000-0003-0970-3514}}
\author[2]{Jarno N. Alanko\ORCID{0000-0002-8003-9225}}
\author[2]{Elena Biagi\ORCID{0000-0002-8573-3603}}
\author[2]{Simon J. Puglisi\ORCID{0000-0001-7668-7636}}

\authormark{M\"{a}klin et al.}

\address[1]{\orgdiv{Department of Mathematics and Statistics}, \orgname{University of Helsinki}, \orgaddress{\street{Pietari Kalmin katu 5}, \postcode{00560}, \state{Helsinki}, \country{Finland}}}
\address[2]{\orgdiv{Department of Computer Science}, \orgname{University of Helsinki}, \orgaddress{\street{Pietari Kalmin katu 5}, \postcode{00560}, \state{Helsinki}, \country{Finland}}}

\corresp[$\ast$]{Corresponding author. \href{email:tommi.maklin@helsinki.fi}{tommi.maklin@helsinki.fi}}

\received{Date}{0}{Year}
\revised{Date}{0}{Year}
\accepted{Date}{0}{Year}

%\editor{Associate Editor: Name}

%\abstract{
%\textbf{Motivation:} .\\
%\textbf{Results:} .\\
%\textbf{Availability:} .\\
%\textbf{Contact:} \href{name@email.com}{name@email.com}\\
%\textbf{Supplementary information:} Supplementary data are available at \textit{Journal Name}
%online.}

\abstract{
Finding high-quality local alignments between a query sequence and sequences contained in large genomic databases is a fundamental problem in computational genomics, at the core of thousands of biological analysis pipelines. Here, we describe an algorithm for approximate local alignment search based on the longest common suffix lengths of consecutive \emph{k}-mer matches between a target and a query sequence (a '\emph{k}-bounded matching statistic'). We compute the \emph{k}-bounded matching statistics using the Spectral Burrows-Wheeler transform (SBWT), a data structure that enables computationally efficient queries and an indexing. Our algorithm is available as a set of three {\sf kbo} Rust packages that provide a command-line interface, a graphical user interface that runs in a browser and does not require server-side processing, and a library that can be accessed by other tools.}
\keywords{sequence alignment, genomics, Spectral Burrows-Wheeler transform, \emph{k}-bounded matching statistics}

% \boxedtext{
% \begin{itemize}
% \item Key boxed text here.
% \item Key boxed text here.
% \item Key boxed text here.
% \end{itemize}}

\maketitle


\section{Introduction}
Genome analysis pipelines often begin with a step where the DNA contained in a genome sequencing run is mapped against a database of known reference sequences computationally. Tools implementing these algorithms make use of a number of indexing structures with different trade-offs in efficiency and accuracy and each come with their own strengths and weaknesses. Broadly speaking, the most typical trade-off is between runtime and accuracy depending on whether the algorithm attempts to find the best global match or search for a number of local matches. The latter is usually preferred in tasks involving large amounts of query and reference data.

Bacterial genomics is a particular field in which the increasing commercial and public health interest in translational research utilizing pathogen genomics has led to explosive growth in data volumes. From an algorithm design perspective, this growth has steered the field towards methods that preferably scale (sub)linearly in the number of reference sequences, as algorithms developed for careful analysis of a few dozen queries at most choke when applied to orders of magnitudes larger databases. Typically, the extra information contained in the larger volume of reference data is enough to justify some loss of accuracy or theoretical guarantees for optimal results. This has led to the adoption of \emph{k}-mer based approaches that use minimizers or hashing techniques to upscale the throughput when compared to the more traditional approaches built on top of the Burrows-Wheeler transform. \textcolor{red}{TODO: citations, add pseudoalignment}

In this paper, we focus on the task of finding local alignment sections within a query sequence in a reference database containing either a small number of bacterial genomes or a larger number of gene sequences. In practice, these represent the two common bacterial genomics use cases of 1) producing reference-based alignments by locally aligning segments from a query against the reference and formatting the output as a string of nucleotide characters and gaps, and 2) comparing the identity and coverage of some genes of interest in a query against the same genes in the reference. For the first task, the most widely used tools are Snippy~\cite{seemann2015snippy}, which uses the Burrows-Wheeler aligner BWA-MEM \cite{li2013aligning} and thus guarantees some locality in the results, and split \emph{k}-mer analysis SKA \cite{derelle2024seamless, harris2018SKA} which discards locality entirely in favour of rapid queries implemented using split \emph{k}-mer hashing. The second approach is typically solved with locality preserving methods such as BWA-MEM, BLAST, or minimap2~\cite{bty191} \textcolor{red}{TODO citations / other relevant methods?}. Our approach, called {\sf kbo}\footnote{\url{https://github.com/tmaklin/kbo}}, is competitive in both tasks 1 and 2.

{\sf kbo} is built on top of the Spectral Burrows-Wheeler transform (SBWT), which allows rapid $k$-mer lookup in compact space~\cite{alanko2023small}. Recently, it was shown that by adding longest common suffix information to the SBWT~\cite{alanko2023longest}, it is possible to quickly compute the length of the longest matching suffix of each $k$â€“mer in the query against the indexed $k$-mers \cite{alanko2024finimizers}. We show that these \emph{$k$-bounded matching statistics} enable transforming the otherwise locality-discarding SBWT \emph{k}-mer matching into an output format that preserves locality of consecutive \emph{k}-mers in the query with a high probability \textcolor{red}{TODO this should be proven or otherwise shown in the manuscript}. 

The main advantage of {\sf kbo} lies in its effective use of the SBWT data structure to perform comparisons in a rapid and parallelisable manner. As an example, pairwise comparison of two 5Mb bacterial genomes (task 1) takes 1-2 seconds using a consumer-grade laptop and looking up a dozen genes of interest (task 2) less than a second. Neither of the tasks requires a separate indexing step, as SBWT construction is efficient enough to embed it in the query steps. Additionally, {\sf kbo} is available as both a command-line interface and a WebAssembly distributable which enables running queries in the browser without sending any data to a remote server and without performing a local install of the tool.

\section{Methods}\label{methods}
\subsection{Overview}

Our tool, {\sf kbo}, implements two main modes of operation: "find" matches the \emph{k}-mers in a query sequence with the reference, and reports the local alignment segments found within the reference. Find is useful for problems that can be solved with BLAST. The second mode, "map", maps the query sequence against a reference sequence, and reports the nucleotide sequence of the alignment relative to the reference. Map solves the same problem as Snippy~\cite{seemann2015snippy} and the map command in SKA \cite{derelle2024seamless}. A command-line interface to these two commands is provided by the kbo-cli Rust package \footnote{\url{https://github.com/tmaklin/kbo-cli}} and the WebAssembly graphical user interface in the kbo-gui package \footnote{\url{https://github.com/tmaklin/kbo-gui}}. An overview of the operation is provided in Fig. \ref{fig1} and in the following paragraphs.
\begin{figure*}[!t]%
\centering
{\includesvg{Figure_kbo_overview.svg}}
\caption{\textbf{Draft} Overview of the {\sf kbo} algorithms.}\label{fig1}
\end{figure*}

Under the hood, kbo-cli and kbo-gui call the functions provided by the kbo core library. This library is responsible for calling the sbwt Rust crate\footnote{\url{https://docs.rs/sbwt}} to perform both indexing of the reference (in kbo find) or the query sequence (kbo map) and query the constructed index with the \emph{k}-mers from the query (in kbo find) or the reference (in kbo map). The query step consists of extracting the \emph{k}-mer matches and querying the longest common suffix (LCS) array for the matching statistics (MS) as described in a previous publication \cite{alanko2024finimizers}.

The resulting MS vector is fed to a \emph{derandomization} algorithm introduced in this paper. This algorithm takes the MS vector and zeroes values that have a high probability to result from a random longest common suffix match. Using the derandomized values, {\sf kbo} can then translate the resulting derandomized MS vector into a character string representing various levels of compatibility between the query and the reference. The character representation may further be refined to resolve single nucleotide polymorphisms (SNPs) in the query, as the plain derandomized MS vector does not contain enough information to distinguish between a SNP and a single base insertion. In kbo map, the refinement step is required, while in kbo find, the derandomized MS vector alone is enough to determine the output values. The next sections will cover each step in detail and introduce the derandomization, translation, and refinement algorithms.

\subsection{\textit{k}-mer matching with the spectral Burrows-Wheeler transform}\label{kmermatching}

In this section, we give a brief overview of the SBWT data structure that lies at the heart {\sf kbo}. We provide here only the key definitions necessary to grasp its function and use; the motivation and theory behind the definitions are described in detail in prior work~\cite{alanko2023small, alanko2023longest, alanko2024finimizers}.

The SBWT sorts the last characters of the distinct $k$-mers in the input by the \emph{colexicographic} (right-to-left lexicographic) order of their prefixes of length $k-1$. To give the precise definition, we first need to introduce the concept of the \emph{padded $k$-spectrum}. First, the $k$-spectrum of a string is the set of distinct $k$-mers in the string.

\begin{definition}($k$-Spectrum) The $k$-spectrum $\mathcal{S}_k(S)$ of string a $S$ is the set of distinct $k$-mers $\{S[i..i+k-1] \; | \; i = 1 , \ldots, |S|-k+1\}$.
%\end{definition}
%
%\begin{definition}($k$-Spectrum of a set of strings) 
The $k$-spectrum $\mathcal{S}_k(S_1, \ldots, S_m)$ of a set of strings $S_1, \ldots, S_m$ is the union $\bigcup_{i = 1}^m \mathcal{S}_k(S_i)$.
\end{definition}

\noindent Informally, a \emph{padded $k$-spectrum} adds a minimal set of $\$$-padded \emph{dummy} $k$-mers to ensure that in the de Bruijn graph of $S_1, \ldots, S_m$ and the dummer $k$-mers, every non-dummy $k$-mer has an incoming path of length at least $k$.

\begin{definition}\label{def:padded_k_spectrum} (Padded $k$-Spectrum)
Let $R = \mathcal{S}_k(S_1, \ldots, S_m)$ be a $k$-spectrum with alphabet $\Sigma$, and let $R' \subseteq R$ be the set of $k$-mers $Y$ such that $Y[1..k-1]$ is not a suffix of any $k$-mer in $R$. The padded $k$-spectrum is the set $\mathcal{S}_k^+(S_1, \ldots, S_m) = R \cup \{\$^k\} \cup \bigcup_{Y \in R'} \{\$^{k-i} Y[1..i] \; | \; i = 1, \ldots, k-1\}$, with special character $\$ \not\in \Sigma$ and $\$ < c$ for all $c \in \Sigma$.
\end{definition}
\noindent For example, if $S_1 = $ {\sf ACGT}, $S_2 = $ {\sf GACG} and $k=3$, then $\mathcal{S}_3(X_1, X_2) = \{ {\sf ACG }, {\sf CGT }, {\sf GAC }\}$ and $\mathcal{S}_3^+(X_1, X_2) = $ $\{{\sf ACG }, {\sf CGT}, {\sf GAC }, {\sf \$\$\$}, {\sf \$\$G}, {\sf \$GA} \}$.

We are now ready to define the SBWT.

\begin{definition}\label{def:SBWT}(Spectral Burrows-Wheeler transform (SBWT)~\cite{alanko2023small}) Let $R^+$ be a padded $k$-spectrum and let $S_1, \ldots, S_{|R|}$ be the elements of $R^+$ in colexicographic order. The SBWT is the sequence of sets $A_1, \ldots, A_{|R|}$ with $A_i \subseteq \Sigma$ such that $A_i = \emptyset$ if $i > 1$ and $S_i[2..k] = S_{i-1}[2..k]$, otherwise $A_i = \{c \in \Sigma \; | \; S_i[2..k]c \in R^+\}$.
\end{definition}
The Longest Common Suffix array is the key to efficient computation of the $k$-bounded matching statistics (to be defined in the next section):

\begin{definition}\label{def:LCS-array}(Longest Common Suffix ($LCS$) Array~\cite{alanko2023longest})     
Let $R^+$ be a padded $k$-spectrum and let $X_i$ be the colexicographically $i$-th $k$-mer of $R^+$. 
The $LCS$ array is an array of length $|R^+|$ s.t. $LCS[1] = 0$, and for $i > 1$, $LCS[i]$ is the length of the longest common suffix of $S_{i-1}$ and $S_i$.
\end{definition}
\textcolor{red}{TODO: example or point to fig 2}. In the above definition, we consider the empty string as a common suffix of any two $k$-mers, so that the longest common suffix is well-defined for any pair of $k$-mers.

When then $k$-mers in $R^+$ colexicographically sorted, the subset of $k$-mers in $R^+$ that share a string $\alpha$ as a suffix are next to each other. This is called the \emph{colexicographic range} of $\alpha$. The colexicographic range of a string $\alpha$ that is \emph{longer} than $k$ is defined as the range of $k$-mers in the sorted list of $R^+$ that have the last $k$ characters of $\alpha$ as a suffix. The SBWT provides two operations on colexicographic ranges $[\ell, r]$ of any string $\alpha$: 

\begin{itemize}
\item ExtendRight($\ell, r, c$) returns the colexicoraphic range of string $\alpha c$ (possibly an empty range).
\item ContractLeft($\ell, r$), defined only if $|\alpha| \geq 1$, returns the colexicographic range of $\alpha[2..|\alpha|]$ if $|\alpha| >1$ or $R^+$ if $|\alpha|=1$. \textcolor{red}{TODO:can we write this better? longest proper suffix of $\alpha$ if it exists, $R^+$ otherwise?}
\end{itemize}

See Alanko et al. \cite{alanko2024finimizers} for details on how to implement these operations using the SBWT.

\begin{figure*}
    \centering
    \includegraphics[scale=0.6]{fig/SBWT_search_LCS.drawio.pdf}
    \caption{Illustration of {\em ExtendRight} (resulting in blue intervals) and {\em ContractLeft} operations (resulting in green intervals) to query the string {\sf GTATG}.}
    %\caption{ Illustration of three {\em ExtendRight} (resulting in blue intervals) and three {\em ContractLeft} operations (resulting in green intervals). GTATGTT\textcolor{red}{[TODO: maybe make a new example] }}
    \label{fig:sbwt-search}
\end{figure*}

\subsection{\texorpdfstring{$k$-bounded matching statistics}{k-bounded matching statistics}}

The $k$-bounded matching statistics are defined as follows:

\begin{definition}\label{def:k-bounded-ms}
    The $k$-bounded matching statistics for a query string $Q$ against a set of reference strings $S_1, \ldots, S_m$ is a vector $MS_k[1..|Q|]$ such that $MS_k[i]$ is the largest integer $l \leq k$ such that $Q[i-l+1..i]$ %\textcolor{red}{$Q[i..i-d+1]$ this is not a suffix ending in i}
    is a substring of at least one reference $S_1, \ldots, S_m$.
\end{definition}

In what follows, we drop the subscript of $MS_k$ since $k$ is assumed constant throughout the paper.

The padded $k$-spectrum $R^+$ provides an equivalent and formulation that is easier to compute: the value of $MS[i]$ is the length $l$ of the longest \emph{suffix of a $k$-mer} in the padded spectrum of $T_1, \ldots, T_m$ that matches $Q[i..i-l+1]$. The $k$-mers in $R^+$ that have suffix $Q[i..i-d+1]$ are adjacent in the colexicographically sorted list of $k$-mers in $R^+$ (the colexicographic range of $Q[i..i-l+1]$). Algorithm \ref{alg:MS} shows pseudocode to compute the MS vector and the colexicographic ranges $[\ell, r]$ corresponding to the longest match at each position.

\begin{algorithm}
\begin{algorithmic}[1]
\small
\Require A query string $Q$ and a data structure supporting $ExtendRight$ and $ContractLeft$ on the padded $k$-mer spectrum. %in constant time. \\
\Ensure $MS_k[1..|Q|]$
\State $\ell, r \gets [1,n]$ \Comment{The current colexicographic interval}
\State $l \gets 0$ \Comment{The length of the current match, up to $k$}
\State $MS_k[1..|Q|] \gets $ Array of length $|Q|$.
\For{$i = 1..|Q|$}
\While{$l > 0 \textbf{ and } ExtendRight(\ell, r, Q[i]) = \emptyset$}\label{line:MS-1-start}
    \State $\ell, r \gets ContractLeft(\ell, r)$
    \State $l \gets l-1$
\EndWhile \label{line:MS-1-end}
\If{$ExtendRight(\ell, r, Q[i]) \neq \emptyset$}
    \State $\ell, r \gets ExtendRight(\ell, r, Q[i])$\label{line:MS-2-start}
    \State $p \gets \min(k, l+1)$\label{line:MS-2-end}
\EndIf
\State $MS_k[i] \gets d$ \Comment{The frequency of the match is $r - \ell + 1$} \label{line:MS-4-assignment}
\EndFor
\caption{\small $k$-bounded matching statistics.} 
\label{alg:MS}
\end{algorithmic}
\end{algorithm}

\subsection{Distribution of longest common suffix lengths in random string matching}
Querying the SBWT index for a query string $Q$ produces a matching statistics (MS) vector  $MS_k[1..N]$ such that $MS_k[i] \in \left[0,k\right], i=1,\ldots , |Q|, |Q| \in \mathbb{N}^+ $ denotes the length of the \emph{longest common suffix} of the corresponding \emph{k}-mer in $Q$ - ending at index $i$ - and the SBWT. For any reasonably large index, most \emph{k}-mers will have a non-zero but small matching statistic due to random chance, the probability of which can be approximated by considering random matching of two strings of infinite length.

Let $\mathcal{X}$ be a random variable denoting the length $t$ of the longest common prefix of two uniformly random and infinitely long strings $S_{1,\infty}$ and $S_{2,\infty}$. If  $0 < p < 1$ is the probability that any pair of two characters in the two strings $S_{1,\infty}, S_{2,\infty}$ are mismatched, then $X$ follows the geometric distribution with cumulative distribution function (CDF)

\begin{equation}
    P\left(\mathcal{X} \leq t\right) = 1 - \left(1 - p\right)^{t + 1}, t \in \mathbb{N}
\label{geom-distribution}
\end{equation}

Suppose that an index $\mathcal{I}$ contains $n$ uniformly random strings $S_{1,k},S_{2,k}$ of length $k$ instead. Assuming that $k$ is large enough that the probability that two strings $S_{1,k},S_{2,k}$ from the index match by chance is negligible, the longest common prefix of these two strings is reasonably approximated by the distribution of the random variable $\mathcal{X}$ (\textcolor{red}{TODO this may need a proof or an example, there is one in Jarno's original writeup}).

Now, let $M$ be a random variable denoting the length of the longest common prefix between some string $S_{k}$ of length $k$ and the entire index $\mathcal{I}$ containing some number of strings of the same length $k$. 
Since distribution of the longest common prefix of the query string $S_k$ and any string $S_i \in \mathcal{I}$ from the index $\mathcal{I}$ is given by the random variable $\mathcal{X}$, 
we can define a new random variable $\mathcal{M}$ 
which is the maximum of $n$ independent random variables with the same distribution as 
$\mathcal{X}$ by setting 
$\mathcal{M} = \text{max}\left\{\mathcal{X}_1, \text{\textellipsis}, \mathcal{X}_n\right\}$. 
Because the variables $\mathcal{X}$ were assumed independent, the CDF of $\mathcal{M}$ is the product of $n$ random variables with the cumulative distribution function from Equation (\ref{geom-distribution})

\begin{equation}
    P\left(M \leq t\right) = P\left(\mathcal{X} \leq t\right)^n = \left(1 - \left(1 - p\right)^{t + 1}\right)^n
\label{max-of-geom-distributions}    
\end{equation}

By noting that $p = 1 - q$, Equation (\ref{max-of-geom-distributions}) simplifies to the the cumulative distribution function

\begin{equation}
    P\left(M \leq t\right) = \left(1 - q^{t + 1}\right)^n
\label{max-error-cdf}
\end{equation}

The CDF in Equation (\ref{max-error-cdf}) can be used to derive a threshold for considering a longest common suffix length value as nonrandom with high probability.

\subsection{\texorpdfstring{Derandomizing $k$-bounded matching statistic vectors}{Derandomizing k-bounded matching statistic vectors}}

Assuming some acceptable probability $0 < p < 1,$ $p$ small, for a random match length, we can derive a corresponding threshold $t_p, 0 < t_p \leq k$ for considering a match length nonrandom with some simple algebra from Equation (\ref{max-error-cdf})

\begin{equation}
    t_p = \text{argmin}_t \left\{\left(1 - q^{t + 1}\right)^n > 1-p \right\}
\label{derand-threshold}
\end{equation}

\textcolor{red}{Todo: solve the equation above for $t$}

Using the threshold $t_p$ from Equation (\ref{derand-threshold}), we can create a \emph{derandomized} version $d = d_1, \dots, d_N$ of the matching statistics vector $MS$ by iterating over $MS$ in reverse and applying the following procedure on the elements $MS[n] = ms_N, \dots, ms_1$
\begin{enumerate}
\item If $MS[n] > t_p$ and $MS[n+1] < MS[n]$,  then $d_n = MS[n]$,
\item If $MS[n] = k$, then $d_n = k$,
\item By default $d_n = MS[n+1] - 1$
\end{enumerate}

This will give a vector $d$ of length $N$ containing a positive value whenever the corresponding matching statistic is derived from a real \emph{k}-mer match with high probability. Zeros in $d$ mark the first base after end of a match, and negative values denote 0-indexed distance from the last matching base. The key to this simple procedure is reading the matching statistics vector $MS$ in reverse and using the threshold $t_p$ to determine when a new match begins after a gap.

\subsection{Translating derandomized matching statistics into alignments}

\begin{figure*}[!t]%
\centering
{\includesvg{Figure_translate_cases}}
\caption{\textbf{Draft Applying the translation procedure to a derandomized matching statistics vector.}. Panel a) shows the result of translating a single position at a time. Panel b) shows the result of translating an entire vector with multiple cases. Examples in both panels assume \emph{k}-mer size 3 and derandomization threshold 2.}\label{fig2}
\end{figure*}

The derandomized MS vector can be translated into a character representation of the compatibility between the query and a reference sequence. The possible cases are displayed in Figure \ref{fig2}a. We encode the character representation using the following set of characters for the different possible compatibility events:
\begin{enumerate}
\item[] \textbf{M}: Match between query and reference.
\item[] \textbf{-}: Bases in the query that are not found in the reference.
\item[] \textbf{X}: Single base mismatch \textit{or} single base insertion into the query.
\item[] \textbf{R}: Two consecutive â€™Râ€™s signify a discontinuity in the alignment. The right â€˜Râ€™ is at the start of a k-mer that is not adjacent to the last character in the k-mer corresponding to the left â€˜Râ€™. This implies either a deletion of unknown length in the query, or insertion of k-mers from elsewhere in the reference into the query.
\end{enumerate}

The translation $t_n$ for each value in the derandomized MS vector $d_n$ depends on the neighboring values $d_{n - 1}$, $d_{n + 1}$ and the threshold $t_p$. We use the following algorithm to determine the character representation of the events
\begin{enumerate}
\item If $d_n > t_p$ and $d_{n + 1} > 0$ and $d_{n + 1} < t_p$, \\ then $t_n = \text{'R'}$ and $t_{n + 1} = \text{'R'}$.
\item If $d_n <= 0$, then there is a mismatch in the query and we apply
    \begin{enumerate}
    \item If $d_{n + 1} = 1$ and $d_{n - 1} > 0$, then $t_n = \text{'X'}$.
    \item Else $t_n = \text{'-'}$.
    \end{enumerate}
\item By default $t_n = \text{'M'}$
\end{enumerate}
Here we would also like to refer the reader to the documentation for the "translate\_ms\_vec" and "translate\_ms\_val" functions in the translate module \footnote{https://docs.rs/kbo} for the actual implementation of these algorithms.

Applying the translation procedure over a more complex derandomized MS vector with multiple events is illustrated in Figure \ref{fig2}b. Note how this case illustrates that the procedure is not able to distinguish between a single base insertion and a single base substitution. This problem can be resolved by adding a \textit{refinement} step to our translation, which resolves this conundrum by using the nucleotide sequence of the reference.

\subsection{Refining the translation to resolve SNPs versus insertions}
\textcolor{red}{TODO this needs a description of how the base is deemed as a SNP (substitution?) or an insertion in the first place.}

We can resolve the problem of single nucleotide substitution versus an insertion by using the colexicographical ordering stored in the LCS array\cite{alanko2023longest}. Briefly, this data structure allows retrieving the neighboring (in the colexicographical ordering) bases from the SBWT and provides an educated guess for the value of the base marked with an X. The SBWT by itself does not store the original sequence but using the LCS array allows us to derive a workaround.

We resolve the 'X's by checking whether the \emph{k}-mer whose first character overlaps the 'X' has a matching statistic of $k - 1$ and, if it does, traversing the colexicographical ordering until we find the \emph{k}-mer where the position marked by 'X' is the middle base (a split \emph{k}-mer centered on 'X' \cite{derelle2024seamless}). We use the middle base from this \emph{k}-mer to replace the 'X' in the translation. If the matching statistic is less than $k - 1$, the character is checked from the \emph{k}-mer that is $(t_p + 1)/2$ characters away from the â€˜Xâ€™ to ensure account for the possibility of a random match.

Although the colexicographical ordering is not guaranteed to return the exact \emph{k}-mer that is present in the query at this position, in practice the approach selects the same nucleotide as Snippy and SKA with a high probability (\textcolor{red}{TODO add figure from a simple example}).

\section{Use cases}

\subsection{Reference-based alignment of query assemblies with 'kbo map'}

Specific to alignment

- alignments are comparable to Snippy and SKA map

- alignment is faster than Snippy or SKA map

- alignment scales easily to 10s of thousands of genomes.

- compare w/ Snippy, SKA map

\subsection{Finding reference gene sequences in a query assembly with 'kbo find'}

Specific to  find

- Quick if it's not needed to know which genes exactly are present

- Slower if the gene names (= individual contigs are needed). this could be implemented more efficiently with colors.

- compare w/ blast

\subsection{Running kbo in the browser}
- efficient resource use: no prebuilt indexes, no temporary space, low memory consumption, runs ok on a single thread

Available online \footnote{https://maklin.fi/kbo}.

\subsection{Browser queries for AllTheBacteria genomes}
- \textcolor{red}{TODO check feasibility of using some served genomes as the query or the target.}

\noindent- \textcolor{red}{TODO make this available as an application for the AllTheBacteria project.}


\section{Discussion}
In no particular order:

- Adding colors: matching statistics queries

- index compression via pangenomes or colorset compression: we can compress ~45 000 genomes from the same species into a few gigabytes using the meta-diff indedx in Fulgor, implementing this in SBWT with efficient MS queries would enable simultaneous alignment against tens of thousands of genomes.

- possibilities for gene variant calling with colors

- finimizers: these together with the recombination markers output by {\sf kbo} (RR) could be used to identify potential recombination segments. Finimizers might additionally allow even more efficient queries with a prebuilt index?

- Mention how the webassembly version enables implementing tools like amrfinder, kaptive, and tree inference in the browser. Use the pks island gene typing as an example of how the custom database inclusion can be utilised.

\section{Code availability}
The Rust\footnote{\url{https://www.rust-lang.org/}} library, command-line interface, and graphical user interface implementing the methods described here are freely available from Codeberg \url{https://codeberg.org/themaklin/sablast} and GitHub \url{https://github.com/tmaklin/kbo} under a MIT\footnote{\url{https://opensource.org/license/mit}} and Apache 2.0\footnote{\url{https://www.apache.org/licenses/LICENSE-2.0}} dual license.

\section{Competing interests}
No competing interest is declared.

\section{Author contributions statement}
T.M. designed the kbo algorithms and implemented the kbo, kbo-cli, and kbo-gui Rust libraries. J.N.A. implemented the sbwt Rust crate and derived the random match distribution. T.M., J.N.A, E.B., and S.J.P. investigated the relationship between \emph{k}-bounded matching statistics and local alignments. S.J.P. obtained funding and supervised the study. All authors contributed to the writing, reviewing, and editing of the manuscript.

\section{Acknowledgments}
This work was supported in part by the Research Council of Finland via grant 351150. TM was supported by the Research Council of Finland (EuroHPC grant).


\bibliographystyle{plain}
\bibliography{reference}


%USE THE BELOW OPTIONS IN CASE YOU NEED AUTHOR YEAR FORMAT.
%\bibliographystyle{abbrvnat}
%\bibliography{reference}

\end{document}
