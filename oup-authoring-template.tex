%%
%% Copyright 2022 OXFORD UNIVERSITY PRESS
%%
%% This file is part of the 'oup-authoring-template Bundle'.
%% ---------------------------------------------
%%
%% It may be distributed under the conditions of the LaTeX Project Public
%% License, either version 1.2 of this license or (at your option) any
%% later version.  The latest version of this license is in
%%    http://www.latex-project.org/lppl.txt
%% and version 1.2 or later is part of all distributions of LaTeX
%% version 1999/12/01 or later.
%%
%% The list of all files belonging to the 'oup-authoring-template Bundle' is
%% given in the file `manifest.txt'.
%%
%% Template article for OXFORD UNIVERSITY PRESS's document class `oup-authoring-template'
%% with bibliographic references
%%

%%%CONTEMPORARY%%%
\documentclass[unnumsec,webpdf,contemporary,large]{oup-authoring-template}%
%\documentclass[unnumsec,webpdf,contemporary,large,namedate]{oup-authoring-template}% uncomment this line for author year citations and comment the above
%\documentclass[unnumsec,webpdf,contemporary,medium]{oup-authoring-template}
%\documentclass[unnumsec,webpdf,contemporary,small]{oup-authoring-template}

%%%MODERN%%%
%\documentclass[unnumsec,webpdf,modern,large]{oup-authoring-template}
%\documentclass[unnumsec,webpdf,modern,large,namedate]{oup-authoring-template}% uncomment this line for author year citations and comment the above
%\documentclass[unnumsec,webpdf,modern,medium]{oup-authoring-template}
%\documentclass[unnumsec,webpdf,modern,small]{oup-authoring-template}

%%%TRADITIONAL%%%
%\documentclass[unnumsec,webpdf,traditional,large]{oup-authoring-template}
%\documentclass[unnumsec,webpdf,traditional,large,namedate]{oup-authoring-template}% uncomment this line for author year citations and comment the above
%\documentclass[unnumsec,namedate,webpdf,traditional,medium]{oup-authoring-template}
%\documentclass[namedate,webpdf,traditional,small]{oup-authoring-template}

%\onecolumn % for one column layouts

%\usepackage{showframe}

\graphicspath{{fig/}}

% svg images
\usepackage[inkscapelatex=false]{svg}

% line numbers
%\usepackage[mathlines, switch]{lineno}
%\usepackage[right]{lineno}

\theoremstyle{thmstyleone}%
\newtheorem{theorem}{Theorem}%  meant for continuous numbers
%%\newtheorem{theorem}{Theorem}[section]% meant for sectionwise numbers
%% optional argument [theorem] produces theorem numbering sequence instead of independent numbers for Proposition
\newtheorem{proposition}[theorem]{Proposition}%
%%\newtheorem{proposition}{Proposition}% to get separate numbers for theorem and proposition etc.
\theoremstyle{thmstyletwo}%
\newtheorem{example}{Example}%
\newtheorem{remark}{Remark}%
\theoremstyle{thmstylethree}%
\newtheorem{definition}{Definition}

\begin{document}

\journaltitle{Journal Title Here}
\DOI{DOI HERE}
\copyrightyear{2022}
\pubyear{2019}
\access{Advance Access Publication Date: Day Month Year}
\appnotes{Paper}

\firstpage{1}

%\subtitle{Subject Section}

\title[Local alignment with kbo]{Local alignment search with \textit{k}-bounded matching statistics}

\author[1,$\ast$]{Tommi M\"{a}klin\ORCID{0000-0003-0970-3514}}
\author[2]{Jarno N. Alanko\ORCID{0000-0002-8003-9225}}
\author[2]{Elena Biagi\ORCID{0000-0002-8573-3603}}
\author[2]{Simon J. Puglisi\ORCID{0000-0001-7668-7636}}

\authormark{M\"{a}klin et al.}

\address[1]{\orgdiv{Department of Mathematics and Statistics}, \orgname{University of Helsinki}, \orgaddress{\street{Pietari Kalmin katu 5}, \postcode{00560}, \state{Helsinki}, \country{Finland}}}
\address[2]{\orgdiv{Department of Computer Science}, \orgname{University of Helsinki}, \orgaddress{\street{Pietari Kalmin katu 5}, \postcode{00560}, \state{Helsinki}, \country{Finland}}}

\corresp[$\ast$]{Corresponding author. \href{email:tommi.maklin@helsinki.fi}{tommi.maklin@helsinki.fi}}

\received{Date}{0}{Year}
\revised{Date}{0}{Year}
\accepted{Date}{0}{Year}

%\editor{Associate Editor: Name}

%\abstract{
%\textbf{Motivation:} .\\
%\textbf{Results:} .\\
%\textbf{Availability:} .\\
%\textbf{Contact:} \href{name@email.com}{name@email.com}\\
%\textbf{Supplementary information:} Supplementary data are available at \textit{Journal Name}
%online.}

\abstract{Sequence alignment is a fundamental problem in computational genomics. Here, we describe an algorithm for approximate local alignment search based on k-bounded matching statistics of consecutive k-mer matches between a target and a query sequence in the spectral Burrows-Wheeler transform (SBWT). Using the SBWT data structure enables efficient queries without a separate indexing step. Our algorithm is available as the kbo Rust package, which provides a command-line interface and a WebAssembly graphical user interface that runs entirely in the browser. The browser version supports bundling of custom databases, allowing easy deployment of bespoke pipelines on a web server.}
\keywords{sequence alignment, genomics, spectral burrows-wheeler transform, \emph{k}-bounded matching statistics}

% \boxedtext{
% \begin{itemize}
% \item Key boxed text here.
% \item Key boxed text here.
% \item Key boxed text here.
% \end{itemize}}

\maketitle


\section{Introduction}
Genome analysis pipelines often begin with a step where the DNA contained in a genome assembly is mapped against a database of known reference sequences using a computational algorithm. Tools implementing these algorithms make use of a number of data indexing structures that have different properties in terms of efficiency and accuracy and each come with their own strengths and weaknesses. Broadly speaking, the most typical trade-off is between runtime and accuracy depending on whether the algorithm attempts to find the best global match or search for a number of local matches. The latter is usually preferred in tasks leveraging large amounts of query and reference data.

Bacterial genomics is a particular field where the increased commercial and public health interest in translational research utilizing pathogen genomics has resulted in an explosive growth in data volumes. From an algorithm design perspective, this growth has steered the field towards methods that preferably scale (sub)linearly in the number of query sequences, as algorithms developed for careful analysis of a few dozen queries at most choke when applied to tens or hundreds of thousands of queries. Typically, the extra information contained in the larger volume of query data is enough to justify some loss of accuracy or theoretical guarantees for optimal results. This has led to the adoption of \emph{k}-mer based approaches that use minimizers or hashing techniques to upscale the throughput when compared to the more traditional approaches built on top of the Burrows-Wheeler transform.

In this paper, we focus on the task of finding local alignment sections within a query genome assembly in a reference database containing either a small number of bacterial genomes or a larger number of gene sequences. In practice, these represent the two common bacterial genomics use-cases of 1) producing reference-based alignments by locally aligning segments from a query against the reference and formatting the output as a string of nucleotide characters and gaps, and 2) comparing the identity and coverage of some genes of interest in a query against the same genes in the reference. For the first task, the most widely used tools are snippy\cite{seemann2015snippy}, which uses the Burrows-Wheeler aligner bwa-mem \cite{li2013aligning} and thus guarantees some locality in the results, and split \emph{k}-mer analysis ska \cite{derelle2024seamless, harris2018ska} which discards locality entirely in favour of rapid queries implemented using split \emph{k}-mer hashing. Our approach, called kbo\footnote{\url{https://codeberg.org/themaklin/sablast}}, is competitive in both tasks.

kbo is built on top of the spectral Burrows-Wheeler transform (SBWT) which allows rapid \emph{k}-mer matching queries\cite{alanko2023small} and was recently extended with efficient lookups of the longest common prefix length for each match\cite{alanko2024finimizers} using a longest common prefix array\cite{alanko2023longest}. We show that performing the \emph{k}-mer matching query together with the longest common prefix length lookup enables transforming the otherwise locality-discarding SBWT \emph{k}-mer matching into an output format that preserves locality of consecutive \emph{k}-mers in the query with a high probability. The main advantage of our approach is in leveraging the SBWT data structure to enable pairwise comparison of 5Mb bacterial genomes in less than a second using a consumer-grade laptop and without the need for a separate indexing step. Our implementation is also available as a WebAssembly distributable that runs in the browser without any server-side processing or a local install.

\section{Methods}\label{methods}
\subsection{Overview}

Our tool, kbo, implements two main modes of operation: "find" matches the \emph{k}-mers in a query sequence with the reference and reports the local alignment segments found within the reference. Find is useful for problems that can be solved with blast. The second mode, "map", maps the query sequence against a reference sequence, and reports the nucleotide sequence of the alignment relative to the reference. Map solves the same problem as snippy\cite{seemann2015snippy} and the map command in ska \cite{derelle2024seamless}. These two commands are provided by the kbo-cli Rust package. An overview of the operation is provided in Fig. \ref{fig1} and in the following paragraphs.
\begin{figure*}[!t]%
\centering
{\includesvg{Figure_kbo_overview.svg}}
\caption{\textbf{Draft} Overview of the kbo algorithms.}\label{fig1}
\end{figure*}

Under the hood, kbo-cli calls the functions provided by the kbo core library. This library is responsible for calling the sbwt Rust crate\footnote{\url{https://docs.rs/sbwt}} to perform both indexing of the reference (in kbo find) or the query sequence (kbo map) and query the constructed index with the \emph{k}-mers from the query (in kbo find) or the reference (in kbo map). The query step consists of extracting the \emph{k}-mer matches and querying the LCS array for the matching statistics as described in \cite{alanko2024finimizers}.

The resulting MS vector is fed to a derandomizer algorithm introduced in this paper which removes results that are likely the result of a random match. The derandomized values can then optionally be translated into a character string representing various levels of compatibility between the query and the reference. This representation may further be refined to resolve single nucleotide substitions in the query. In kbo find, the derandomized MS vector is enough to determine the output values, while kbo map requires the translation and refinement steps. The next sections will cover the different steps in detail and introduce the derandomization, translation, and refinement algorithms.

\subsection{\textit{k}-mer matching with the spectral Burrows-Wheeler transform}\label{kmermatching}
Algbio ppl pls write short description, we might also want to add some figures from Jarno's SBWT crate documentation.

\subsection{\textit{k}-bounded matching statistics}
Algbio ppl pls write short description

\subsection{Distribution of longest common prefix lengths in random string matching}

Querying the SBWT index produces a matching statistics (MS) vector $MS = \left(ms_1, \dots, ms_N\right)$ where each value $ms_n \in \left[0,k\right], n = 1, \dots, N, N \in \mathbb{N}^+$ denotes the length of the \emph{longest common prefix} of the corresponding \emph{k}-mer $k_n$ that is found in the index $\mathcal{I}$. For any reasonably large index, most \emph{k}-mers will have a non-zero but small matching statistic due to random chance, the probability of which can be approximated by considering random matching of two strings of infinite length.

Let $\mathcal{X}$ be a random variable denoting the length $t$ of the longest common prefix of two uniformly random and infinitely long strings $s_{1,\infty}$ and $s_{2,\infty}$. If  $0 < p < 1$ is the probability that any pair of two characters in the two strings $s_{1,\infty}, s_{2,\infty}$ are mismatched, then $X$ follows the geometric distribution with cumulative distribution function (CDF)

\begin{equation}
    P\left(\mathcal{X} \leq t\right) = 1 - \left(1 - p\right)^{t + 1}, t \in \mathbb{N}
\label{geom-distribution}
\end{equation}

Suppose that an index $\mathcal{I}$ contains $n$ uniformly random strings $s_{1,k},s_{2,k}$ of length $k$ instead. Assuming that $k$ is large enough that the probability that two strings $s_{1,k},s_{2,k}$ from the index match by chance is negligible, the longest common prefix of these two strings is reasonably approximated by the distribution of the random variable $\mathcal{X}$ (TODO this may need a proof or an example).

Now, let $M$ be a random variable denoting the length of the longest common prefix between some string $s_{k}$ of length $k$ and the entire index $\mathcal{I}$ containing some number of strings of the same length $k$. Since distribution of the longest common prefix of the query string $s_k$ and any string $s_i \in \mathcal{I}$ from the index $\mathcal{I}$ is given by the random variable $\mathcal{X}$, we can define a new random variable $\mathcal{M}$ which is the maximum of $n$ independent random variables with the same distribution as $\mathcal{X}$ by setting $\mathcal{M} = \text{max}\left\{\mathcal{X}_1,…,\mathcal{X}_n\right\}$. Because the variables $\mathcal{X}$ were assumed independent, the CDF of $\mathcal{M}$ is the product of $n$ random variables with the cumulative distribution function from Equation (\ref{geom-distribution})

\begin{equation}
    P\left(M \leq t\right) = P\left(\mathcal{X} \leq t\right)^n = \left(1 - \left(1 - p\right)^{t + 1}\right)^n
\label{max-of-geom-distributions}    
\end{equation}

By noting that $p = 1 - q$, Equation (\ref{max-of-geom-distributions}) simplifies to the the cumulative distribution function

\begin{equation}
    P\left(M \leq t\right) = \left(1 - q^{t + 1}\right)^n
\label{max-error-cdf}
\end{equation}

The CDF in Equation (\ref{max-error-cdf}) can be used to derive a threshold for considering a longest common prefix length value as nonrandom with high probability.

\subsection{Derandomizing \textit{k}-bounded matching statistic vectors}

Assuming some acceptable probability $0 < p < 1,$ $p$ small, for a random match length, we can derive a corresponding threshold $t_p, 0 < t_p \leq k$ for considering a match length nonrandom with some simple algebra from Equation (\ref{max-error-cdf})

\begin{equation}
    t_p = \text{argmin}_k \left\{\left(1 - q^{t + 1}\right)^n > q^p \right\}
\label{derand-threshold}
\end{equation}

Using the threshold $t_p$ from Equation (\ref{derand-threshold}), we can create a \emph{derandomized} version $d = d_1, \dots, d_N$ of the matching statistics vector $ms$ by iterating over $ms$ in reverse and applying the following procedure on the elements $ms_n = ms_N, \dots, ms_1$
\begin{enumerate}
\item If $ms_n > t_p$ and $ms_{n + 1} < ms_n$,  then $d_n = ms_n$,
\item If $ms_n = k$, then $d_n = k$,
\item By default $d_n = ms_{n + 1} - 1$
\end{enumerate}

This will result the vector $d$ containing a positive value whenever the corresponding matching statistic is derived from a real \emph{k}-mer match with high probability. Zeros in $d$ mark the first base after end of a match, and negative values denote 0-indexed distance from the last matching base. The key to this simple procedure is reading the matching statistics vector $ms$ in reverse and using the threshold $t_p$ to determine when a new match begins after a gap.

\subsection{Translating derandomized matching statistics into alignments}

\begin{figure*}[!t]%
\centering
{\includesvg{Figure_translate_cases}}
\caption{\textbf{Draft Applying the translation procedure to a derandomized matching statistics vector.}. Panel a) shows the result of translating a single position at a time. Panel b) shows the result of translating an entire vector with multiple cases. Examples in both panels assume \emph{k}-mer size 3 and derandomization threshold 2.}\label{fig2}
\end{figure*}

The derandomized MS vector can be translated into a character representation of the compatibility between the query and a reference sequence. The possible cases are displayed in Figure \ref{fig2}a. We encode the character representation of using the following set of characters for the different possible compatibility events:
\begin{enumerate}
\item[] \textbf{M}: Match between query and reference.
\item[] \textbf{-}: Bases in the query that are not found in the reference.
\item[] \textbf{X}: Single base mismatch \textit{or} single base insertion into the query.
\item[] \textbf{R}: Two consecutive ’R’s signify a discontinuity in the alignment. The right ‘R’ is at the start of a k-mer that is not adjacent to the last character in the k-mer corresponding to the left ‘R’. This implies either a deletion of unknown length in the query, or insertion of k-mers from elsewhere in the reference into the query.
\end{enumerate}

The translation $t_n$ for each value in the derandomized MS vector $d_n$ depends on the neighboring values $d_{n - 1}$, $d_{n + 1}$ and the thresolhd $t_p$. We use the following algorithm to determine the character representation of the events
\begin{enumerate}
\item If $d_n > t_p$ and $d_{n + 1} > 0$ and $d_{n + 1} < t_p$, \\ then $t_n = R$ and $t_{n + 1} = R$.
\item If $d_n <= 0$, then there is a mismatch in the query and we apply
    \begin{enumerate}
    \item If $d_{n + 1} = 1$ and $d_{n - 1} > 0$, then $t_n = X$.
    \item Else $t_n = -$.
    \end{enumerate}
\item By default $t_n = M$
\end{enumerate}
Here we would also like to refer the reader to the "translate\_ms\_vec" and "translate\_ms\_val" functions in the translate module of our kbo library implementation.

Applying all the translation procedure over a more complex derandomized MS vector with multiple events is illustrated in Figure \ref{fig2}b. Note how this case illustrates that the procedure is not able to distinguish between a single base insertion and a single base substition. This problem can be resolved by adding a \textit{refinement} step to our translation, which resolves this conundrum by using the nucleotide sequence of the reference.

\subsection{Resolving SNPs versus insertions relative to a reference sequence}
We can resolve the problem of single nucleotide substitution versus an insertion by using the \textit{colexicographical ordering} stored in the LCS array\cite{alanko2023longest}. Briefly, this data structure allows retrieving the neighboring (in the colexicographical ordering) bases from the SBWT and provide an educated guess for the value of the base marked with an X. The SBWT by itself does not store the original sequence but using the LCS array allows us to derive a workaround.

We resolve the X's by checking whether the \emph{k}-mer whose first character overlaps the X has a matching statistic of $k - 1$ and, if it does, traversing the colexicographical ordering until we find the \emph{k}-mer where the position marked by X is the middle base (a split \emph{k}-mer centered on X \cite{derelle2024seamless}). We use the middle base from this \emph{k}-mer to replace the X in the translation. If the matching statistic is less than k - 1, the character is checked from the k-mer that is (threshold + 1)/2 characters away from the ‘X’ to ensure account for the possibility of a random match.

Although the colexicographical ordering is not guaranteed to return the exact \emph{k}-mer that is present in the query at this position, in practice the approach selects the correct nucleotide with a high probability when compared to snippy and ska (TODO add figure).

\section{Use cases}

\subsection{Reference-based alignment of query assemblies with 'kbo map'}

Specific to alignment

- alignments are comparable to snippy and ska map

- alignment is faster than snippy or ska map

- alignment scales easily to 10s of thousands of genomes.

- compare w/ snippy, ska map

\subsection{Finding reference gene sequences in a query assembly with 'kbo find'}

Specific to  find

- Quick if it's not needed to know which genes exactly are present

- Slower if the gene names (= individual contigs are needed). this could be implemented more efficiently with colors.

- compare w/ blast

\subsection{Running kbo in the browser}
- efficient resource use: no prebuilt indexes, no temporary space, low memory consumption, runs ok on a single thread


\section{Discussion}
In no particular order:

- Adding colors: matching statistics queries

- index compression via pangenomes or colorset compression: we can compress ~45 000 genomes from the same species into a few gigabytes using the meta-diff indedx in Fulgor, implementing this in SBWT with efficient MS queries would enable simultaneous alignment against tens of thousands of genomes.

- possibilities for gene variant calling with colors

- finimizers: these together with the recombination markers output by kbo (RR) could be used to identify potential recombination segments. Finimizers might additionally allow even more efficient queries with a prebuilt index?

\section{Code availability}
The Rust\footnote{\url{https://www.rust-lang.org/}} library, command-line interface, and graphical user interface implementing the methods described here are freely available from Codeberg \url{https://codeberg.org/themaklin/sablast} and GitHub \url{https://github.com/tmaklin/sablast} under a MIT\footnote{\url{https://opensource.org/license/mit}} and Apache 2.0\footnote{\url{https://www.apache.org/licenses/LICENSE-2.0}} dual license.

\section{Competing interests}
No competing interest is declared.

\section{Author contributions statement}

Must include all authors, identified by initials, for example:
S.R. and D.A. conceived the experiment(s),  S.R. conducted the experiment(s), S.R. and D.A. analysed the results.  S.R. and D.A. wrote and reviewed the manuscript.

\section{Acknowledgments}
TM was supported by the Research Council of Finland (EuroHPC grant).


\bibliographystyle{plain}
\bibliography{reference}


%USE THE BELOW OPTIONS IN CASE YOU NEED AUTHOR YEAR FORMAT.
%\bibliographystyle{abbrvnat}
%\bibliography{reference}

\end{document}
